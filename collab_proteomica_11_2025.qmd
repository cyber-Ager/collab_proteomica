---
title: "Proteomic Analysis"
subtitle: "Collaboration with the Bio-Chemistry group"
author: 
  - name: Ager Uribezubia Azpitarte
    affiliations:
      - name: Institut de Recerca de Sant Pau - UGMC
  - name: Pol Ezquerra Condeminas
    affiliations:
      - name: Institut de Recerca de Sant Pau - UGMC
date: "January 10, 2025"
format: 
  html:
    code-fold: true
    embed-resources: true
---

## Organize the data

```{r, message=F, include=FALSE}
# Install Required Packages
if (!require("BiocManager", quietly = TRUE)) {
  install.packages("BiocManager")
}

if (!require("dplyr", quietly = TRUE)) {
  install.packages("dplyr")
}

if (!require("pheatmap", quietly = TRUE)) {
  BiocManager::install("pheatmap")
}

if (!require("ggplot2", quietly = TRUE)) {
  install.packages("ggplot2")
}

if (!require("reshape2", quietly = TRUE)) {
  install.packages("reshape2")
}

if (!require("tidyr", quietly = TRUE)) {
  BiocManager::install("tidyr")
}

if (!require("patchwork", quietly = TRUE)) {
  install.packages("patchwork")
}

if (!require("ggrepel", quietly = TRUE)) {
  install.packages("ggrepel")
}

if (!require("tibble", quietly = TRUE)) {
  install.packages("tibble")
}

if (!require("here", quietly = TRUE)) {
  install.packages("here")
}

if (!require("factoextra", quietly = TRUE)) {
  BiocManager::install("factoextra")
}

if (!requireNamespace("limma", quietly = TRUE)) {
  BiocManager::install("limma")
  }

if (!requireNamespace("DT", quietly = TRUE)) {
  install.packages("DT")
  }

if (!requireNamespace("htmltools", quietly = TRUE)) {
  install.packages("htmltools")
  }
```


```{r}
# Load required packages
library(dplyr)
library(tidyr)
library(pheatmap)
library(ggplot2)
library(reshape2)
library(patchwork)
library(ggrepel)
library(limma)
library(tibble)
library(here)
library(DT)
library(htmltools)


```


```{r, message=FALSE, echo=FALSE}
# Set working directory to the own folder of the file
setwd(here())

# Define Root file to Bioinf02 or local path
local_path  <- "/home/ir_user/PhD/Obese_proteomica/" # Set your local path (if wanted)
remote_base <- file.path(Sys.getenv("HOME"), "bioinf02")
remote_rel  <- "ager/collab/bioquimica/bmi_proteomics/inputs/2025PROT002-70.xlsx"

# Detect environment
if (dir.exists(local_path)) {
    message("Working in LOCAL environment.")
    file_path1 <- file.path(local_path, "2025PROT002-70.xlsx")  
} else {
    message("Working in REMOTE environment.")
    file_path1 <- file.path(remote_base, remote_rel)
}

cat("Using file:\n", file_path1, "\n")

# Read file1
pr_ALL <- readxl::read_xlsx(file_path1)

# Filter the columns of interest
expr_ALL <- pr_ALL[,!is.na(as.matrix(pr_ALL)[1,])]

# Set column and row names
colnames(expr_ALL) <- expr_ALL[1,]

# Remove first row from datasets
expr_ALL <- expr_ALL[2:nrow(expr_ALL),]

# Convert expr matrix in numeric
expr_ALL <- sapply(expr_ALL, as.numeric)
row.names(expr_ALL) <- pr_ALL$`Protein IDs`[!is.na(pr_ALL$`Protein IDs`)]

# Create the meta-data matrix for proteins
meta_pr <- pr_ALL[2:nrow(expr_ALL),is.na(as.matrix(pr_ALL)[1,])]

# Create the meta-data matrix for patients (Same as file_path1)
if (dir.exists(local_path)) {
    message("Working in LOCAL environment.")
    file_path2 <- file.path(local_path, "Secretoma Ob per Lipid Proteo i AC16.xlsx")  
} else {
    message("Working in REMOTE environment.")
    file_path2 <- file.path(remote_base, "ager/collab/bioquimica/bmi_proteomics/inputs/Secretoma Ob per Lipid Proteo i AC16.xlsx")
}

meta_pat <- readxl::read_xlsx(file_path2)

# Correct colnames
colnames(meta_pat)[1] <- "id"

# Read the Raw protein table
if (dir.exists(local_path)) {
    message("Working in LOCAL environment.")
    file_path3 <- file.path(local_path, "proteinGroups.txt")  
} else {
    message("Working in REMOTE environment.")
    file_path3 <- file.path(remote_base, "ager/collab/bioquimica/bmi_proteomics/inputs/proteinGroups.txt")
}

raw_pr <- read.table(file_path3, sep = "\t", header = TRUE)


# Remove NA rows and Add grouping variable
meta_pat <- meta_pat %>% 
  dplyr::filter(!is.na(id)) %>%
  dplyr::mutate(group = as.factor(toupper(substr(id, 1,2))),
                Sexo = as.factor(Sexo),
                Otros = as.factor(ifelse(is.na(Otros), "No", Otros)),
                # Correct the meta_pat ID to make the same as expr_ALL
                id = as.factor(paste0(group, tidyr::extract_numeric(id))),
                )
```

### Before correction
```{r}
summary(meta_pat)
```


### After correction
```{r}
meta_pat$IMC[meta_pat$id == "NW3"] <- 21.6

summary(meta_pat)
```


```{r}
knitr::kable(
meta_pat %>% 
  group_by(group) %>% 
  select(-Num) %>%
  summarise(across(where(is.numeric),
                   list(mean = mean, sd = sd, min = min, max = max),
                   .names = "{.col}_{.fn}")))

```


## Data exploration
### Statistical comparison between groups: 

**Objective:** Check the group imbalance respect the variables Sex and DM.

```{r, warning=FALSE, message=FALSE}
chi_square_group <- function(var) {
  
  tab <- table(meta_pat$group, meta_pat[[var]])
  expected <- chisq.test(tab)$expected
  
  # If some expected < 5 → Fisher
  if (any(expected < 5)) {
    test <- fisher.test(tab)
    method <- "Fisher Exact test"
  } else {
    test <- chisq.test(tab)
    method <- "Chi-square test"
  }
  
  list(
    variable = var,
    method = method,
    table = tab,
    p_value = test$p.value
  )
}

res_sexo  <- chi_square_group("Sexo")
res_otros <- chi_square_group("Otros")

res_sexo
```
The distribution of sex across groups does not seems imbalanced.

```{r, warning=FALSE, message=FALSE}
res_otros
```
The distribution of DM across groups is highly unbalanced (Fisher’s exact test p = 5.7×10⁻⁴), indicating a strong and statistically significant association between having diabetes and overweight.

::: {.callout-warning}
**Confounding Bias:** Having an unbalanced group means that is not possible to know if the study results are really associated to the phenotype of interest (Obessity & Over Weight) or to the counfounding variable (DM), as there is no way to separate the effect of these two variables. 
:::

### Heat Map

```{r}
# Add groups to see if cluster together
annotation_col <- data.frame(Group = factor(meta_pat$group))
rownames(annotation_col) <- colnames(expr_ALL)

pheatmap(expr_ALL,
         color = colorRampPalette(c("blue", "yellow"))(100),
         cluster_rows = TRUE,
         cluster_cols = TRUE,
         show_rownames = FALSE,
         annotation_col = annotation_col,
         main = "Expression heatmap")
```
### Heat Map (100 variable proteins): 

```{r}

# Compute variance for each protein
gene_var <- apply(expr_ALL, 1, var)

# Select top 100 most variable proteins
top100_genes <- names(sort(gene_var, decreasing = TRUE))[1:100]
expr_top100 <- expr_ALL[top100_genes, ]

pheatmap(expr_top100,
         color = colorRampPalette(c("blue", "yellow"))(100),
         cluster_rows = TRUE,
         cluster_cols = TRUE,
         show_rownames = FALSE,
         annotation_col = annotation_col,
         main = "Expression heatmap (Top 100 most variable proteins)")
```

It can be seen how there is no a clear clusterization of patients. However if we check the k=3 clusters, we can see how it seems that all the control grouo falls in almost in the same group. We can check further if there is some key aspects about this differentiation.

::: {.callout-tip}
## Interesting Subjects
It can be seen how the *OW8* and the *OB8* patients seem to have different protein distribution compared to the rest of the opatients. Could be interesting to see if there are some other variables affecting to this differentiation.
:::

```{r}
res <- pheatmap(expr_top100, silent = TRUE) 
col_clusters <- cutree(res$tree_col, k = 3)

# Add col_cluster to dataset
meta_pat$k3 <- as.factor(col_clusters)

# 0) Prepare a DM variable robustly
if ("DM" %in% names(meta_pat)) {
  meta_pat <- meta_pat %>% mutate(DM_var = as.factor(DM))
} else {
  # try to detect 'DM' mention inside Otros (case-insensitive)
  if ("Otros" %in% names(meta_pat)) {
    meta_pat <- meta_pat %>%
      mutate(DM_var = ifelse(grepl("\\bDM\\b|diabete|diabetes", Otros, ignore.case = TRUE),
                             "yes", "no"),
             DM_var = factor(DM_var, levels = c("no", "yes")))
  } else {
    # fallback: create an NA column so code still runs
    meta_pat <- meta_pat %>% mutate(DM_var = factor(NA))
    warning("No DM or Otros column found: DM_var set to NA for all rows.")
  }
}

# Quick contingency tables (printed)
# cat("Counts: group by k3\n")
# print(table(meta_pat$k3, meta_pat$group))
# cat("\nCounts: Sexo by k3\n")
# print(table(meta_pat$k3, meta_pat$Sexo))
# cat("\nCounts: DM_var by k3\n")
# print(table(meta_pat$k3, meta_pat$DM_var))

# 1) Bar plot: group per k3 (counts)
p1 <- p1 <- ggplot(meta_pat, aes(x = k3, fill = group)) +
  geom_bar(position = position_dodge(width = 0.8)) +
  scale_fill_manual(values = c(
    "NW" = "steelblue",
    "OW" = "orange",
    "OB" = "firebrick"
  )) +
  labs(title = "Counts of NW / OW / OB per cluster (k3)",
       x = "Cluster (k3)",
       y = "Count") +
  theme_minimal() +
  theme(legend.position = "right")

# 2) Bar plot: Sexo per k3
p2 <- ggplot(meta_pat, aes(x = k3, fill = Sexo)) +
  geom_bar(position = position_dodge(width = 0.8)) +
  scale_fill_manual(values = c(
    "F" = "#C77CFF",  # lilac
    "M" = "#2E8B57"   # green (sea green)
  )) +
  labs(title = "Counts of Sex per cluster (k3)",
       x = "Cluster (k3)",
       y = "Count") +
  theme_minimal() +
  theme(legend.position = "right")

# 3) Bar plot: DM (detected) per k3
# If DM_var is all NA, show an informative plot (empty)
if (all(is.na(meta_pat$DM_var))) {
  p3 <- ggplot() +
    annotate("text", x = 1, y = 1, label = "No DM information available", size = 5) +
    labs(title = "DM counts per k3") +
    theme_void()
} else {
  p3 <- ggplot(meta_pat, aes(x = k3, fill = DM_var)) +
  geom_bar(position = position_dodge(width = 0.8)) +
  scale_fill_manual(values = c(
    "no"  = "#87CEEB",  # soft green
    "yes" = "#808080"  # muted purple
  )) +
  labs(title = "Counts of DM per cluster (k3)",
       x = "Cluster (k3)",
       y = "Count",
       fill = "DM") +
    theme(legend.position = "right")
}

# 4) Boxplot: Edad by k3
p4 <- ggplot(meta_pat, aes(x = k3, y = Edad)) +
  geom_boxplot() +
  geom_jitter(width = 0.2, size = 1, alpha = 0.7) +
  labs(title = "Age (Edad) distribution by cluster (k3)",
       x = "Cluster (k3)",
       y = "Edad (years)") +
  theme_minimal()

# Combine into 2x2 layout
combined_plot <- (p1 | p2) / (p3 | p4) +
  plot_annotation(title = "Summary of clusters (k3) by group / sex / DM / age")

# Print the combined plot
print(combined_plot)

# Optionally save
# ggsave("k3_summary_2x2.png", combined_plot, width = 12, height = 9, dpi = 300)
```
### Main protein differences across clusters

We compute the average expression difference between the three clustered groups and we ploted heat maps with the Top 20 proteins with higher average differences between groups. This way is possible to see which proteins were influenciating the separation of these clusters.

```{r}
# Required packages
library(dplyr)
library(pheatmap)

# Make sure sample names line up (coerce id to character)
meta_pat <- meta_pat %>% mutate(id = as.character(id))
expr_top100 <- expr_top100[, meta_pat$id]   # reorder columns to match meta_pat

# Ensure k3 is a factor with sensible ordering
k3 <- factor(meta_pat$k3, levels = sort(unique(meta_pat$k3)))

# 1) Compute mean expression per protein per k3
cluster_means <- sapply(levels(k3), function(cl) {
  rowMeans(expr_top100[, meta_pat$k3 == cl, drop = FALSE])
})
colnames(cluster_means) <- paste0("k3_", levels(k3))

# 2) Compute the difference (max - min) across clusters for each protein
range_diff <- apply(cluster_means, 1, function(x) max(x) - min(x))

# 3) Select top 20 proteins by that range
top20 <- names(sort(range_diff, decreasing = TRUE))[1:20]

# 4) Build a summary table for the top20
top20_table <- data.frame(
  protein = top20,
  range = range_diff[top20],
  max_cluster = apply(cluster_means[top20, , drop = FALSE], 1, function(x) {
    levels(k3)[which.max(x)]
  }),
  stringsAsFactors = FALSE
)
# append cluster means as columns
top20_table <- cbind(top20_table, as.data.frame(cluster_means[top20, , drop = FALSE]))
top20_table <- top20_table %>% arrange(desc(range))

# Print the summary table
knitr::kable(top20_table)
```


```{r}
# 5) Order columns for heatmap: by k3, then by sample mean across top20
sample_means_top20 <- colMeans(expr_top100[top20, , drop = FALSE])
samp_df <- data.frame(id = colnames(expr_top100),
                      k3 = meta_pat$k3,
                      sample_mean = sample_means_top20,
                      stringsAsFactors = FALSE)
samp_df <- samp_df %>% arrange(k3, sample_mean)
sample_order <- samp_df$id

# 6) Prepare annotation for columns
annotation_col <- data.frame(k3 = factor(meta_pat$k3, levels = levels(k3)),
                             group = meta_pat$group)
rownames(annotation_col) <- meta_pat$id

# Optional: annotation colors (pick any palette you like)
annotation_colors <- list(
  k3 = setNames(c("#F8766D", "#00BA38", "#619CFF")[seq_along(levels(k3))], levels(k3)),
  group = c("NW" = "steelblue", "OW" = "orange", "OB" = "firebrick")
)

# 7) Plot pheatmap: scale rows to emphasize differences across proteins
pheatmap(expr_top100[top20, sample_order],
         scale = "row",
         cluster_rows = TRUE,
         cluster_cols = FALSE,        # columns are already ordered by k3 & sample mean
         show_rownames = TRUE,
         show_colnames = FALSE,
         annotation_col = annotation_col,
         annotation_colors = annotation_colors,
         color = colorRampPalette(c("blue", "white", "red"))(100),
         main = "Top 20 proteins (max-min across clusters)")

```

In this plot we can see how the higher differences are influenced mainly by **group 3**,  as these two patients have significantly different protein patterns compared to the other groups. Because of this reason we consider to check the differences between group1 vs group 2 and repeat the process.

#### Protein differences Group 1 vs Group 2

```{r}
# 2) Compute the difference (max - min) across clusters for each protein
range_diff <- abs(cluster_means[, "k3_2"] - cluster_means[, "k3_1"])

# 3) Select top 20 proteins by that range
top20 <- names(sort(range_diff, decreasing = TRUE))[1:20]

# 4) Build a summary table for the top20
top20_table <- data.frame(
  protein = top20,
  range = range_diff[top20],
  max_cluster = apply(cluster_means[top20, , drop = FALSE], 1, function(x) {
    levels(k3)[which.max(x)]
  }),
  stringsAsFactors = FALSE
)
# append cluster means as columns
top20_table <- cbind(top20_table, as.data.frame(cluster_means[top20, , drop = FALSE]))
top20_table <- top20_table %>% arrange(desc(range))

# Print the summary table
knitr::kable(top20_table)
```


```{r}
# 5) Order columns for heatmap: by k3, then by sample mean across top20
sample_means_top20 <- colMeans(expr_top100[top20, , drop = FALSE])
samp_df <- data.frame(id = colnames(expr_top100),
                      k3 = meta_pat$k3,
                      sample_mean = sample_means_top20,
                      stringsAsFactors = FALSE)
samp_df <- samp_df %>% arrange(k3, sample_mean)
sample_order <- samp_df$id

# 6) Prepare annotation for columns
annotation_col <- data.frame(k3 = factor(meta_pat$k3, levels = levels(k3)),
                             group = meta_pat$group)
rownames(annotation_col) <- meta_pat$id

# Optional: annotation colors (pick any palette you like)
annotation_colors <- list(
  k3 = setNames(c("#F8766D", "#00BA38", "#619CFF")[seq_along(levels(k3))], levels(k3)),
  group = c("NW" = "steelblue", "OW" = "orange", "OB" = "firebrick")
)

# 7) Plot pheatmap: scale rows to emphasize differences across proteins
pheatmap(expr_top100[top20, sample_order],
         scale = "row",
         cluster_rows = TRUE,
         cluster_cols = FALSE,        # columns are already ordered by k3 & sample mean
         show_rownames = TRUE,
         show_colnames = FALSE,
         annotation_col = annotation_col,
         annotation_colors = annotation_colors,
         color = colorRampPalette(c("blue", "white", "red"))(100),
         main = "Top 20 proteins (max-min across group 1 vs group 2)")
```


### Protein values per patient

We plot the protein distribution across patients in order to see if the expression pattern is similar or not.

```{r}
# Add probe IDs as a column
exprs_ALL_df <- data.frame(Protein = rownames(expr_ALL), expr_ALL)

# Melt the data frame into long format
expr_long <- reshape2::melt(exprs_ALL_df, id.vars = "Protein", variable.name = "patient", value.name = "Expression") 

# Add group variable
expr_long <- expr_long %>%
  dplyr::mutate(group = as.factor(substr(patient, 1,2)))


# Density plot
a <- ggplot(expr_long, aes(x = Expression, color = patient)) +
  geom_density() +
  theme_bw() +
  ggtitle("Expression density distributions per patient")

b <- ggplot(expr_long, aes(x = Expression, fill = 1)) +
  geom_density(alpha = 0.5) +
  theme_bw() +
  theme(legend.position = "none") +
  ggtitle("General expression density distributions")

# Density plot
c <- ggplot(expr_long, aes(x = Expression, color = group, fill = group)) +
  geom_density(alpha = 0.1) +
  theme_bw() +
  ggtitle("Expression density distributions per group")

# Density plot
d <- ggplot(expr_long, aes(x = Expression, color = group, fill = group)) +
  geom_boxplot(alpha = 0.1) +
  theme_bw() +
  ggtitle("Expression distributions' boxplots per group")


final_plot <- (a|b) / (c|d)


ggsave(
  filename = "results/expression_density_combined.png",
  plot = final_plot,
  width = 12,     # adjust as needed
  height = 10,    # adjust as needed
  dpi = 300
)
```

![](results/expression_density_combined.png)

### Mean vs SD per Protein

We also check the distribution of protein expression and the standard deviation of them acorss patients.

```{r}
# Compute mean and SD across patients for each protein
protein_stats <- exprs_ALL_df %>%
  tidyr::pivot_longer(-Protein, names_to = "patient", values_to = "Expression") %>%
  dplyr::group_by(Protein) %>%
  dplyr::summarise(
    mean_expr = mean(Expression, na.rm = TRUE),
    sd_expr   = sd(Expression, na.rm = TRUE)
  )
# Density plot of mean expression values
a <- ggplot(protein_stats, aes(x = mean_expr)) +
  geom_density(fill = "steelblue", alpha = 0.4) +
  theme_bw() +
  ggtitle("Density of Mean Expression Per Protein") +
  xlab("Mean Expression")

# Scatter plot: SD vs mean per protein
b <- ggplot(protein_stats, aes(x = mean_expr, y = sd_expr)) +
  geom_point(alpha = 0.6) +
  theme_bw() +
  ggtitle("SD vs Mean Expression per Protein") +
  xlab("Mean Expression") +
  ylab("Standard Deviation")

a | b
```

## Outlier exclusion

As we have seen that there are two individuals that can clearly be differentiated with the rest in the heat map, we decide to remove them: **OB8 and OW8**

::: {.callout-warning}
## Importance of the Oulier's origin

It is imporatnt to know where are the outliers coming from. We decide to eliminate because we saw that the difference of these samples with the rest of the population is significant and can be caused by an artifact, but it is **neccesary to determine the origin of this bias** in order to trust the results of the analysis.**

:::

```{r}
# Eliminate it from the exor_ALL matrix
expr_ALL <- expr_ALL[,!colnames(expr_ALL) %in% c("OW8", "OB8")]

meta_pat <- meta_pat[!meta_pat$id %in% c("OW8", "OB8"),]
```


## Principal Component Analysis

This section performs a principal component analysis to explore global patterns in the protein expression data. First, the sample metadata is reordered so that it matches the order of samples in the expression matrix. This is essential to ensure that each sample is correctly annotated. The expression matrix is then transposed so that samples are treated as observations and proteins as variables, which is required for principal component analysis. The analysis **reduces thousands of protein measurements into a small number of components that summarize the main sources of variation** in the data.

If the variable is numeric, such as age, samples are colored along a continuous scale to show gradients across the data. If the variable is categorical, such as group or sex, samples are colored by category and confidence ellipses are added to visualize clustering tendencies. This approach helps evaluate whether samples with shared characteristics tend to group together in the global expression space. The resulting plots are arranged into a single figure for side by side comparison.

```{r, warning = FALSE, message=FALSE}
# Ensure metadata is ordered to match expression matrix
meta_pat <- meta_pat[match(colnames(expr_ALL), meta_pat$id), ]

# Transpose so samples are rows for PCA
pca_res <- prcomp(t(expr_ALL), scale. = TRUE)

# build PCA dataframe
pca_df <- data.frame(
  PC1 = pca_res$x[, 1],
  PC2 = pca_res$x[, 2],
  PC3 = pca_res$x[, 3],
  PC4 = pca_res$x[, 4],
  id = meta_pat$id,
  group = meta_pat$group,
  Sexo = meta_pat$Sexo,
  Otros = meta_pat$Otros,
  Edad = meta_pat$Edad
)

# Create PC pairs
pc_pairs <- list(
  c("PC1","PC2"),
  c("PC1","PC3"),
  c("PC1","PC4"),
  c("PC2","PC3"),
  c("PC2","PC4"),
  c("PC3","PC4")
)

# Meta variables 

color_vars <- c("Sexo", "Otros", "Edad", "group")


# Function to create pca_plot
make_pca_plot <- function(df, pcs, color_var) {
  ggplot(df, aes_string(x = pcs[1], y = pcs[2], color = color_var)) +
    geom_point(size = 3) +
    geom_text_repel(aes(label = id), size = 3) +
    theme_bw() +
    ggtitle(paste0(pcs[1], " vs ", pcs[2], " colored by ", color_var)) +
    xlab(paste0(pcs[1], " (", round(summary(pca_res)$importance[2, as.numeric(substr(pcs[1],3,3))] * 100, 1), "%)")) +
    ylab(paste0(pcs[2], " (", round(summary(pca_res)$importance[2, as.numeric(substr(pcs[2],3,3))] * 100, 1), "%)"))
}

# Generate plot list
plots <- list()

# Create each pca plot
for (pc in pc_pairs) {
  for (colvar in color_vars) {
    p <- make_pca_plot(pca_df, pc, colvar)
    plots <- append(plots, list(p))
  }
}

# Combinar todos los gráficos en una cuadrícula
final_plot <- wrap_plots(plots, ncol = 2)

# Save PCA plots
ggsave("results/PCA_all_combinations.png",
       final_plot,
       width = 16, height = 40, dpi = 300)

# print(final_plot)
```

![](results/PCA_all_combinations.png)
We can see how the **PC4** (for example when plotting it against PC2) seems to capturate a bit the effect of the sex in the population. These indications determine the need to correct the analyses by gender.

```{r, warning = FALSE, message=FALSE}
# Add groups to see if cluster together
library(factoextra)
library(ggpubr)
library(ggplot2)

# PCA with factoextra
res.pca <- prcomp(t(expr_ALL), scale.=TRUE, center=TRUE)

# Variables wanted to plot: 
vars <- c("group", "Sexo", "Otros", "Edad")
plots <- list()

for (v in vars) {
  vec <- meta_pat[[v]]
  # If numeric variable: 
  if (is.numeric(vec)) {
    
    p <- fviz_pca_ind(res.pca,
                      addEllipses = FALSE,
                      repel = TRUE, 
                      label = "none"
    ) +
      geom_point(aes(color = vec), size = 3) +
      scale_color_viridis_c(option = "plasma") +
      labs(color = v, title = paste("PCA grouped by", v))
    
  } else {
    # Categorical variable: 
    p <- fviz_pca_ind(res.pca,
                      addEllipses = TRUE,
                      ellipse.level = 0.95,
                      repel = TRUE,
                      palette = "Dark2",
                      habillage = vec, 
                      label = "none"
    )  +
      labs(title = paste("PCA grouped by", v))
  }
  
  # Save plot
  plots[[v]] <- p
}

# Combine 4 plots:
ggarrange(
  plots$group, plots$Sexo, plots$Otros, plots$Edad,
  # labels = vars,
  ncol = 2, nrow = 2
)

```

# Data models

## Individual protein levels

### BMI level model

Now, we are going to prepare the data for statistical modeling of individual protein expression levels. The metadata is again aligned with the expression matrix to guarantee correct sample matching. **Body mass index and age are transformed in two ways**. First, they are **centered** (in 0) **to make model interpretation more intuitive**. Second, they are **standardized** so that **all numeric predictors** are on **comparable scales**, which improves model stability. The objective is to analyze how protein levels changes if the bmi changes. 

A preliminary linear model is fitted to evaluate collinearity among predictors. Variance inflation factors and diagnostic plots are used to check whether predictors provide redundant information. This step ensures that subsequent models are statistically sound and interpretable.

```{r, warning = FALSE, message=FALSE}
library(car)
# reorder metadata to match expr_ALL columns
meta_pat <- meta_pat[match(colnames(expr_ALL), meta_pat$id), ]

# basic check
stopifnot(all(colnames(expr_ALL) == meta_pat$id))

# Optionally center continuous covariates (helps interpret intercepts)
meta_pat$IMC_c  <- scale(meta_pat$IMC, center = TRUE, scale = FALSE)[,1]
meta_pat$Edad_c <- scale(meta_pat$Edad, center = TRUE, scale = FALSE)[,1]

# Scale numeric covariates to be on similar scales:
# Center and scale (z-score)
meta_pat$IMC_s  <- scale(meta_pat$IMC, center = TRUE, scale = TRUE)[,1]
meta_pat$Edad_s <- scale(meta_pat$Edad, center = TRUE, scale = TRUE)[,1]

# Consider looking for colinarity between predictors: 
model_vif <- lm(IMC ~ Edad + Sexo + group + Otros, data=meta_pat)
vif(model_vif)
plot(model_vif, which = 1, main = "Model Fit")
```

In this case, we drop group (it does not reach vif value = 5, but it's 'measuring' the same as the bmi).

After that, a **multivariable linear model** is fitted to test the association between **protein expression and body mass index** while **adjusting for age, sex, and other covariates**. A design matrix is constructed that encodes these predictors in a form suitable for high dimensional modeling. The **limma framework is then applied** to fit the model to all proteins simultaneously.

Empirical Bayes moderation is used to improve variance estimation, which is particularly important when sample sizes are limited. Results for the body mass index effect are extracted for all proteins and **corrected for multiple testing**. A volcano plot is generated to visualize both the magnitude and statistical significance of associations. Proteins with stronger and more significant associations are highlighted and labeled. The plot is saved for inclusion in the report.

```{r, warning = FALSE, message=FALSE}
# IMC: 

### Build design matrix
# Model: Expression ~ IMC + Edad + Sexo
# (Intercept corresponds to reference level of Sexo)
design_bmi <- model.matrix(~ IMC_s + Edad_s + Sexo + Otros, data = meta_pat) # Add DB and scaled data: 

colnames(design_bmi)
# Check design
print(head(design_bmi))

## Fit limma
# expr_ALL must be numeric matrix
expr_mat <- as.matrix(expr_ALL)
fit_bmi <- lmFit(expr_mat, design_bmi)
fit_bmi <- eBayes(fit_bmi, trend = TRUE, robust = TRUE) # Use empirical Bayes with robust options and trend 

### Extract results for BMI (IMC_c)
# Determine the exact coefficient name for IMC_c in design
coef_name <- "IMC_s"
if(!coef_name %in% colnames(design_bmi)) stop("Coefficient name for BMI not found in design.")

res_bmi <- topTable(fit_bmi, coef = coef_name, number = Inf, sort.by = "P") # res contains logFC (effect per unit of IMC_c), AveExpr, t, P.Value, adj.P.Val, B
```


```{r}


# Add proteinID as a column
res_bmi$proteinID <- rownames(res_bmi)

# Optional: move proteinID to first column
res_bmi <- res_bmi[, c("proteinID", setdiff(colnames(res_bmi), "proteinID"))]

dt_bmi <- datatable(
  res_bmi,
  options = list(
    pageLength = 5,
    initComplete = JS(
      "function(settings, json) {",
      "$('div.dataTables_wrapper').find('table').css('font-size', '14px');",
      "$('div.dataTables_wrapper').find('caption').css({'font-size': '16px', 'font-weight': 'bold'});",
      "}"
    ),
    columnDefs = list(
      list(
        targets = "_all",
        render = JS(
          "function(data, type, row, meta) {",
          "  if (typeof data === 'number') {",
          "    if (meta.col == 4 || meta.col == 5) {",  
          "      return parseFloat(data).toExponential(2);",
          "    } else {",
          "      return parseFloat(data).toFixed(3);",
          "    }",
          "  } else {",
          "    return data;",
          "  }",
          "}"
        )
      )
    )
  ),
  rownames = FALSE,
  caption = "BMI multivariate analysis results"
)

browsable(tagList(dt_bmi))

```


```{r, warning = FALSE, message=FALSE}
### 5. Add protein names column (rownames are proteins)
res_bmi <- res_bmi %>% 
  tibble::rownames_to_column(var = "Protein") %>%
  as.data.frame()

### 6. Volcano plot (ggplot2) - custom
# choose thresholds (you can change)
logFC_thr <- 0.2        # example: proteins with abs(logFC) > 0.2 considered biologically relevant (adjust as you wish)
padj_thr  <- 0.05

res_bmi$significant <- with(res_bmi, (adj.P.Val < padj_thr) & (abs(logFC) > logFC_thr))

volc_df_bmi <- res_bmi %>%
  mutate(minusLog10P = -log10(P.Value + 1e-300))  # avoid -Inf

p_volcano_bmi <- ggplot(volc_df_bmi, aes(x = logFC, y = minusLog10P)) +
  geom_point(aes(color = significant), alpha = 0.7) +
  scale_color_manual(values = c("grey50", "red")) +
  geom_vline(xintercept = c(-logFC_thr, logFC_thr), linetype = "dashed") +
  geom_hline(yintercept = -log10(padj_thr), linetype = "dashed") +
  theme_bw() +
  xlab("log2 fold change (per 1 BMI unit)") +
  ylab("-log10(p-value)") +
  ggtitle("Volcano plot: association of protein expression with BMI (IMC)") +
  theme(legend.position = "none")

# label top hits (by smallest adj.P.Val or largest effect)
top_to_label_bmi <- volc_df_bmi %>% arrange(adj.P.Val) %>% head(10)
p_volcano_bmi <- p_volcano_bmi +
  geom_text_repel(data = top_to_label_bmi,
                  aes(label = Protein),
                  size = 3,
                  max.overlaps = 20)

# Show plot (optional)
print(p_volcano_bmi)

# Save to file (PNG)
ggsave("results/volcano_IMC_limma.png", p_volcano_bmi, width = 8, height = 6, dpi = 300)
```

The results seem to be really close to be sttistically significant (<0.05). Take into account that as we are checking the **BMI** (there is no any group information), we are **able to correct by DM**. This means that the differentially expressed **proteins are independent to DM**. 

:::{.callout-important}
When comparing between groups it is **not possible to remove DM effect** completely, as the NW group has 0 cases of DM.

:::

### Group comparisson

Finally, we wanted to evaluate differences in protein expression between predefined groups. First, a linear model is fitted that includes group as the main factor while adjusting for age, sex, and other covariates. An overall statistical test identifies proteins that vary across groups. Then, specific pairwise group comparisons are defined using contrasts.

For each contrast, the model is refitted and statistical results are extracted. A reusable function generates volcano plots for each comparison, highlighting proteins with both large expression differences and strong statistical support. The most significant proteins are labeled to facilitate biological interpretation. As output, you can also find several interactive tables with teh results of the different comparisons: 

```{r, warning = FALSE, message=FALSE}

# Anova (F-test): 
# Design with intercept (recommended)
design_group <- model.matrix(~ group + Edad_c + Sexo + Otros, data = meta_pat)
colnames(design_group) <- make.names(colnames(design_group))

# Verify
stopifnot(qr(design_group)$rank == ncol(design_group))

# Fit model
fit_group <- lmFit(expr_mat, design_group)
fit_group <- eBayes(fit_group, trend = TRUE, robust = TRUE)

res_overall <- topTable(fit_group, coef = grep("^group", colnames(design_group)),
                        number = Inf, sort.by = "F")


# Pairwise comparison: 
# Define contrasts for all pairwise comparisons
contr.matrix <- makeContrasts(
  OB_vs_NW = groupOB,
  OW_vs_NW = groupOW,
  OB_vs_OW = groupOB - groupOW,
  levels = design_group
)

# Fit model
fit2 <- contrasts.fit(fit_group, contr.matrix)
fit2 <- eBayes(fit2, trend = TRUE, robust = TRUE)

tt_over_norm <- topTable(fit2, coef="OW_vs_NW", number=Inf, adjust.method = "BH")
tt_obese_norm <- topTable(fit2, coef="OB_vs_NW", number=Inf, adjust.method = "BH")
tt_obese_over <- topTable(fit2, coef="OB_vs_OW", number=Inf,adjust.method = "BH")

# --- 5. Function to make volcano plots for a given contrast
make_volcano <- function(fit2, contrast_name, logFC_thr = 0.2, padj_thr = 0.05, top_n = 10) {
  res <- topTable(fit2, coef = contrast_name, number = Inf, sort.by = "P") %>%
    rownames_to_column("Protein") %>%
    as.data.frame()
  
  res$significant <- with(res, (adj.P.Val < padj_thr) & (abs(logFC) > logFC_thr))
  res$minusLog10P <- -log10(res$P.Value + 1e-300)
  
  # Volcano plot
  p <- ggplot(res, aes(x = logFC, y = minusLog10P)) +
    geom_point(aes(color = significant), alpha = 0.7) +
    scale_color_manual(values = c("grey50", "red")) +
    geom_vline(xintercept = c(-logFC_thr, logFC_thr), linetype = "dashed") +
    geom_hline(yintercept = -log10(padj_thr), linetype = "dashed") +
    theme_bw() +
    xlab("log2 fold change") +
    ylab("-log10(p-value)") +
    ggtitle(paste0("Volcano: ", contrast_name)) +
    theme(legend.position = "none")
  
  # Label top proteins
  top_to_label <- res %>% arrange(adj.P.Val) %>% head(top_n)
  p <- p + geom_text_repel(data = top_to_label,
                           aes(label = Protein),
                           size = 3,
                           max.overlaps = 20)
  return(p)
}

# --- 6. Make volcano plots for each contrast
p_OB_vs_NW <- make_volcano(fit2, "OB_vs_NW")
p_OW_vs_NW <- make_volcano(fit2, "OW_vs_NW")
p_OB_vs_OW <- make_volcano(fit2, "OB_vs_OW")

# --- 7. Optionally save plots
ggsave("results/volcano_OB_vs_NW.png", p_OB_vs_NW, width = 8, height = 6, dpi = 300)
ggsave("results/volcano_OW_vs_NW.png", p_OW_vs_NW, width = 8, height = 6, dpi = 300)
ggsave("results/volcano_OB_vs_OW.png", p_OB_vs_OW, width = 8, height = 6, dpi = 300)


```

Display the pairwise comparison in interactive tables: 
```{r, warning = FALSE, message=FALSE}
library(DT)
library(htmltools)

tt_over_norm$proteinID <- rownames(tt_over_norm)
tt_obese_norm$proteinID <- rownames(tt_obese_norm)
tt_obese_over$proteinID <- rownames(tt_obese_over)

# Named list of topTables
tt_list <- list(
  "OW_vs_NW" = tt_over_norm,
  "OB_vs_NW" = tt_obese_norm,
  "OB_vs_OW" = tt_obese_over
)

# Create a list of datatables
dt_list <- lapply(seq_along(tt_list), function(i) {
  tt <- tt_list[[i]]
  df_name <- names(tt_list)[i]
  
  datatable(
    head(tt, n = nrow(tt)),
    options = list(
      pageLength = 5,
      initComplete = JS(
        "function(settings, json) {",
        "$('div.dataTables_wrapper').find('table').css('font-size', '14px');",
        "$('div.dataTables_wrapper').find('caption').css({'font-size': '16px', 'font-weight': 'bold'});",
        "}"
      ),
      columnDefs = list(
        list(
          targets = "_all",
          render = JS(
            "function(data, type, row, meta) {",
            "if (typeof data === 'number') {",
            "  if (meta.col == 5) {",
            "    return parseFloat(data).toExponential(2);",
            "  } else {",
            "    return parseFloat(data).toFixed(3);",
            "  }",
            "} else {",
            "  return data;",
            "}",
            "}"
          )
        )
      )
    ),
    rownames = FALSE,
    caption = df_name
  )
})

# Render all tables at once
browsable(tagList(dt_list))
```


# Conclusions

In summary, we reached the following conclusions.

## Observational study

* We identified two individuals, **0B8 and 0W8**, with unusual expression patterns that form isolated clusters, as shown in the heatmap. It would be **important to review the quality control metrics and metadata for these individuals** to determine whether there is a technical or biological explanation.
* The data did not cluster according to the predefined groups. Instead of three clearly separated groups (normal weight, overweight, and obese), we observed three mixed clusters: one consisting of two outlier samples, one cluster containing mostly normal weight individuals with some overweight and obese samples, and another cluster composed mainly of overweight and obese individuals with one normal weight sample. It could be interesting to see what is generating that **first cluster** with **almost all NW individuals** and **what characteristics are shared with the rest of the OB and OW** individuals of the same group.
* No clear differences associated with age or sex were observed.

## Differential expression study
* The analysis was performed **removing the outliers**, so it is **important to make sure that these samples can be removed**.
* We did not identify any statistically significant results after correcting for multiple testing. But the **adjusted p-values in BMI** analysis are **close to be statistically significant**, this shows that there could be a relationship between those proteins and the phenotype of interest. Would be **interesting to study the most significant proteins**.

## Take home message

* We observe trends in protein expression that suggest potential group specific signatures; however, these differences do not remain statistically significant after correction for multiple testing. This is likely due to the small sample size, with only eight individuals included in the study. Increasing the sample size would likely improve statistical power.
* Two mixed clusters were identified. It would be valuable to investigate protein expression differences between these clusters and to assess whether they reflect biological patterns not directly related to body mass index, such as differences in body fat composition. Having access to body fat percentage measurements would be particularly informative.
* We have found that in this small dataset the analysis of BMI is more interesting that the group analysis, due to the imposibilitie of correcting the groups' information by DM.




