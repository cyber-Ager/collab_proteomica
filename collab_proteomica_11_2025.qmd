---
title: "Proteomic Analysis"
subtitle: "Collaboration with the Bio-Chemistry group"
author: 
  - name: Ager Uribezubia Azpitarte
    affiliations:
      - name: Institut de Recerca de Sant Pau - UGMC
  - name: Pol Ezquerra Condeminas
    affiliations:
      - name: Institut de Recerca de Sant Pau - UGMC
date: "January 10, 2025"
format: 
  html:
    code-fold: true
---

## Organize the data

```{r, message=F, include=FALSE}
# Install Required Packages
if (!require("BiocManager", quietly = TRUE)) {
  install.packages("BiocManager")
}

if (!require("dplyr", quietly = TRUE)) {
  install.packages("dplyr")
}

if (!require("pheatmap", quietly = TRUE)) {
  BiocManager::install("pheatmap")
}

if (!require("ggplot2", quietly = TRUE)) {
  install.packages("ggplot2")
}

if (!require("reshape2", quietly = TRUE)) {
  install.packages("reshape2")
}

if (!require("tidyr", quietly = TRUE)) {
  BiocManager::install("tidyr")
}

if (!require("patchwork", quietly = TRUE)) {
  install.packages("patchwork")
}

if (!require("ggrepel", quietly = TRUE)) {
  install.packages("ggrepel")
}

if (!require("tibble", quietly = TRUE)) {
  install.packages("tibble")
}

if (!require("here", quietly = TRUE)) {
  install.packages("here")
}

if (!require("factoextra", quietly = TRUE)) {
  BiocManager::install("factoextra")
}

if (!requireNamespace("limma", quietly = TRUE)) BiocManager::install("limma")
```


```{r}
# Load required packages
library(dplyr)
library(tidyr)
library(pheatmap)
library(ggplot2)
library(reshape2)
library(patchwork)
library(ggrepel)
library(limma)
library(tibble)
library(here)


```


```{r, message=FALSE, echo=FALSE}
# Set working directory to the own folder of the file
setwd(here())

# Define Root file to Bioinf02 or local path
local_path  <- "/home/ir_user/PhD/Obese_proteomica/" # Set your local path (if wanted)
remote_base <- file.path(Sys.getenv("HOME"), "bioinf02")
remote_rel  <- "ager/collab/bioquimica/bmi_proteomics/inputs/2025PROT002-70.xlsx"

# Detect environment
if (dir.exists(local_path)) {
    message("Working in LOCAL environment.")
    file_path1 <- file.path(local_path, "2025PROT002-70.xlsx")  
} else {
    message("Working in REMOTE environment.")
    file_path1 <- file.path(remote_base, remote_rel)
}

cat("Using file:\n", file_path1, "\n")

# Read file1
pr_ALL <- readxl::read_xlsx(file_path1)

# Filter the columns of interest
expr_ALL <- pr_ALL[,!is.na(as.matrix(pr_ALL)[1,])]

# Set column and row names
colnames(expr_ALL) <- expr_ALL[1,]

# Remove first row from datasets
expr_ALL <- expr_ALL[2:nrow(expr_ALL),]

# Convert expr matrix in numeric
expr_ALL <- sapply(expr_ALL, as.numeric)
row.names(expr_ALL) <- pr_ALL$`Protein IDs`[!is.na(pr_ALL$`Protein IDs`)]

# Create the meta-data matrix for proteins
meta_pr <- pr_ALL[2:nrow(expr_ALL),is.na(as.matrix(pr_ALL)[1,])]

# Create the meta-data matrix for patients (Same as file_path1)
if (dir.exists(local_path)) {
    message("Working in LOCAL environment.")
    file_path2 <- file.path(local_path, "Secretoma Ob per Lipid Proteo i AC16.xlsx")  
} else {
    message("Working in REMOTE environment.")
    file_path2 <- file.path(remote_base, "ager/collab/bioquimica/bmi_proteomics/inputs/Secretoma Ob per Lipid Proteo i AC16.xlsx")
}

meta_pat <- readxl::read_xlsx(file_path2)

# Correct colnames
colnames(meta_pat)[1] <- "id"

# Read the Raw protein table
if (dir.exists(local_path)) {
    message("Working in LOCAL environment.")
    file_path3 <- file.path(local_path, "proteinGroups.txt")  
} else {
    message("Working in REMOTE environment.")
    file_path3 <- file.path(remote_base, "ager/collab/bioquimica/bmi_proteomics/inputs/proteinGroups.txt")
}

raw_pr <- read.table(file_path3, sep = "\t", header = TRUE)


# Remove NA rows and Add grouping variable
meta_pat <- meta_pat %>% 
  dplyr::filter(!is.na(id)) %>%
  dplyr::mutate(group = as.factor(toupper(substr(id, 1,2))),
                Sexo = as.factor(Sexo),
                Otros = as.factor(ifelse(is.na(Otros), "No", Otros)),
                # Correct the meta_pat ID to make the same as expr_ALL
                id = as.factor(paste0(group, tidyr::extract_numeric(id))),
                )
```

### Before correction
```{r}
summary(meta_pat)
```


### After correction
```{r}
meta_pat$IMC[meta_pat$id == "NW3"] <- 21.6

summary(meta_pat)
```


```{r}
knitr::kable(
meta_pat %>% 
  group_by(group) %>% 
  select(-Num) %>%
  summarise(across(where(is.numeric),
                   list(mean = mean, sd = sd, min = min, max = max),
                   .names = "{.col}_{.fn}")))

```


## Data exploration
### Statistical comparison between groups: 

**Objective:** Check the group imbalance respect the variables Sex and DM.

```{r, warning=FALSE, message=FALSE}
chi_square_group <- function(var) {
  
  tab <- table(meta_pat$group, meta_pat[[var]])
  expected <- chisq.test(tab)$expected
  
  # If some expected < 5 → Fisher
  if (any(expected < 5)) {
    test <- fisher.test(tab)
    method <- "Fisher Exact test"
  } else {
    test <- chisq.test(tab)
    method <- "Chi-square test"
  }
  
  list(
    variable = var,
    method = method,
    table = tab,
    p_value = test$p.value
  )
}

res_sexo  <- chi_square_group("Sexo")
res_otros <- chi_square_group("Otros")

res_sexo
```
The distribution of sex across groups does not seems imbalanced.

```{r, warning=FALSE, message=FALSE}
res_otros
```
The distribution of DM across groups is highly unbalanced (Fisher’s exact test p = 5.7×10⁻⁴), indicating a strong and statistically significant association between having diabetes and overweight.

::: {.callout-warning}
**Confounding Bias:** Having an unbalanced group means that is not possible to know if the study results are really associated to the phenotype of interest (Obessity & Over Weight) or to the counfounding variable (DM), as there is no way to separate the effect of these two variables. 
:::

### Heat Map

```{r}
# Add groups to see if cluster together
annotation_col <- data.frame(Group = factor(meta_pat$group))
rownames(annotation_col) <- colnames(expr_ALL)

pheatmap(expr_ALL,
         color = colorRampPalette(c("blue", "yellow"))(100),
         cluster_rows = TRUE,
         cluster_cols = TRUE,
         show_rownames = FALSE,
         annotation_col = annotation_col,
         main = "Expression heatmap")
```
### Heat Map (100 variable proteins): 

```{r}

# Compute variance for each protein
gene_var <- apply(expr_ALL, 1, var)

# Select top 100 most variable proteins
top100_genes <- names(sort(gene_var, decreasing = TRUE))[1:100]
expr_top100 <- expr_ALL[top100_genes, ]

pheatmap(expr_top100,
         color = colorRampPalette(c("blue", "yellow"))(100),
         cluster_rows = TRUE,
         cluster_cols = TRUE,
         show_rownames = FALSE,
         annotation_col = annotation_col,
         main = "Expression heatmap (Top 100 most variable proteins)")
```

It can be seen how there is no a clear clusterization of patients. However if we check the k=3 clusters, we can see how it seems that all the control grouo falls in almost in the same group. We can check further if there is some key aspects about this differentiation.

::: {.callout-tip}
## Interesting Subjects
It can be seen how the *OW8* and the *OB8* patients seem to have different protein distribution compared to the rest of the opatients. Could be interesting to see if there are some other variables affecting to this differentiation.
:::

```{r}
res <- pheatmap(expr_top100, silent = TRUE) 
col_clusters <- cutree(res$tree_col, k = 3)

# Add col_cluster to dataset
meta_pat$k3 <- as.factor(col_clusters)

# 0) Prepare a DM variable robustly
if ("DM" %in% names(meta_pat)) {
  meta_pat <- meta_pat %>% mutate(DM_var = as.factor(DM))
} else {
  # try to detect 'DM' mention inside Otros (case-insensitive)
  if ("Otros" %in% names(meta_pat)) {
    meta_pat <- meta_pat %>%
      mutate(DM_var = ifelse(grepl("\\bDM\\b|diabete|diabetes", Otros, ignore.case = TRUE),
                             "yes", "no"),
             DM_var = factor(DM_var, levels = c("no", "yes")))
  } else {
    # fallback: create an NA column so code still runs
    meta_pat <- meta_pat %>% mutate(DM_var = factor(NA))
    warning("No DM or Otros column found: DM_var set to NA for all rows.")
  }
}

# Quick contingency tables (printed)
# cat("Counts: group by k3\n")
# print(table(meta_pat$k3, meta_pat$group))
# cat("\nCounts: Sexo by k3\n")
# print(table(meta_pat$k3, meta_pat$Sexo))
# cat("\nCounts: DM_var by k3\n")
# print(table(meta_pat$k3, meta_pat$DM_var))

# 1) Bar plot: group per k3 (counts)
p1 <- p1 <- ggplot(meta_pat, aes(x = k3, fill = group)) +
  geom_bar(position = position_dodge(width = 0.8)) +
  scale_fill_manual(values = c(
    "NW" = "steelblue",
    "OW" = "orange",
    "OB" = "firebrick"
  )) +
  labs(title = "Counts of NW / OW / OB per cluster (k3)",
       x = "Cluster (k3)",
       y = "Count") +
  theme_minimal() +
  theme(legend.position = "right")

# 2) Bar plot: Sexo per k3
p2 <- ggplot(meta_pat, aes(x = k3, fill = Sexo)) +
  geom_bar(position = position_dodge(width = 0.8)) +
  scale_fill_manual(values = c(
    "F" = "#C77CFF",  # lilac
    "M" = "#2E8B57"   # green (sea green)
  )) +
  labs(title = "Counts of Sex per cluster (k3)",
       x = "Cluster (k3)",
       y = "Count") +
  theme_minimal() +
  theme(legend.position = "right")

# 3) Bar plot: DM (detected) per k3
# If DM_var is all NA, show an informative plot (empty)
if (all(is.na(meta_pat$DM_var))) {
  p3 <- ggplot() +
    annotate("text", x = 1, y = 1, label = "No DM information available", size = 5) +
    labs(title = "DM counts per k3") +
    theme_void()
} else {
  p3 <- ggplot(meta_pat, aes(x = k3, fill = DM_var)) +
  geom_bar(position = position_dodge(width = 0.8)) +
  scale_fill_manual(values = c(
    "no"  = "#87CEEB",  # soft green
    "yes" = "#808080"  # muted purple
  )) +
  labs(title = "Counts of DM per cluster (k3)",
       x = "Cluster (k3)",
       y = "Count",
       fill = "DM") +
    theme(legend.position = "right")
}

# 4) Boxplot: Edad by k3
p4 <- ggplot(meta_pat, aes(x = k3, y = Edad)) +
  geom_boxplot() +
  geom_jitter(width = 0.2, size = 1, alpha = 0.7) +
  labs(title = "Age (Edad) distribution by cluster (k3)",
       x = "Cluster (k3)",
       y = "Edad (years)") +
  theme_minimal()

# Combine into 2x2 layout
combined_plot <- (p1 | p2) / (p3 | p4) +
  plot_annotation(title = "Summary of clusters (k3) by group / sex / DM / age")

# Print the combined plot
print(combined_plot)

# Optionally save
# ggsave("k3_summary_2x2.png", combined_plot, width = 12, height = 9, dpi = 300)
```
### Main protein differences across clusters

We compute the average expression difference between the three clustered groups and we ploted heat maps with the Top 20 proteins with higher average differences between groups. This way is possible to see which proteins were influenciating the separation of these clusters.

```{r}
# Required packages
library(dplyr)
library(pheatmap)

# Make sure sample names line up (coerce id to character)
meta_pat <- meta_pat %>% mutate(id = as.character(id))
expr_top100 <- expr_top100[, meta_pat$id]   # reorder columns to match meta_pat

# Ensure k3 is a factor with sensible ordering
k3 <- factor(meta_pat$k3, levels = sort(unique(meta_pat$k3)))

# 1) Compute mean expression per protein per k3
cluster_means <- sapply(levels(k3), function(cl) {
  rowMeans(expr_top100[, meta_pat$k3 == cl, drop = FALSE])
})
colnames(cluster_means) <- paste0("k3_", levels(k3))

# 2) Compute the difference (max - min) across clusters for each protein
range_diff <- apply(cluster_means, 1, function(x) max(x) - min(x))

# 3) Select top 20 proteins by that range
top20 <- names(sort(range_diff, decreasing = TRUE))[1:20]

# 4) Build a summary table for the top20
top20_table <- data.frame(
  protein = top20,
  range = range_diff[top20],
  max_cluster = apply(cluster_means[top20, , drop = FALSE], 1, function(x) {
    levels(k3)[which.max(x)]
  }),
  stringsAsFactors = FALSE
)
# append cluster means as columns
top20_table <- cbind(top20_table, as.data.frame(cluster_means[top20, , drop = FALSE]))
top20_table <- top20_table %>% arrange(desc(range))

# Print the summary table
knitr::kable(top20_table)
```


```{r}
# 5) Order columns for heatmap: by k3, then by sample mean across top20
sample_means_top20 <- colMeans(expr_top100[top20, , drop = FALSE])
samp_df <- data.frame(id = colnames(expr_top100),
                      k3 = meta_pat$k3,
                      sample_mean = sample_means_top20,
                      stringsAsFactors = FALSE)
samp_df <- samp_df %>% arrange(k3, sample_mean)
sample_order <- samp_df$id

# 6) Prepare annotation for columns
annotation_col <- data.frame(k3 = factor(meta_pat$k3, levels = levels(k3)),
                             group = meta_pat$group)
rownames(annotation_col) <- meta_pat$id

# Optional: annotation colors (pick any palette you like)
annotation_colors <- list(
  k3 = setNames(c("#F8766D", "#00BA38", "#619CFF")[seq_along(levels(k3))], levels(k3)),
  group = c("NW" = "steelblue", "OW" = "orange", "OB" = "firebrick")
)

# 7) Plot pheatmap: scale rows to emphasize differences across proteins
pheatmap(expr_top100[top20, sample_order],
         scale = "row",
         cluster_rows = TRUE,
         cluster_cols = FALSE,        # columns are already ordered by k3 & sample mean
         show_rownames = TRUE,
         show_colnames = FALSE,
         annotation_col = annotation_col,
         annotation_colors = annotation_colors,
         color = colorRampPalette(c("blue", "white", "red"))(100),
         main = "Top 20 proteins (max-min across clusters)")

```

In this plot we can see how the higher differences are influenced mainly by **group 3**,  as these two patients have significantly different protein patterns compared to the other groups. Because of this reason we consider to check the differences between group1 vs group 2 and repeat the process.

#### Protein differences Group 1 vs Group 2

```{r}
# 2) Compute the difference (max - min) across clusters for each protein
range_diff <- abs(cluster_means[, "k3_2"] - cluster_means[, "k3_1"])

# 3) Select top 20 proteins by that range
top20 <- names(sort(range_diff, decreasing = TRUE))[1:20]

# 4) Build a summary table for the top20
top20_table <- data.frame(
  protein = top20,
  range = range_diff[top20],
  max_cluster = apply(cluster_means[top20, , drop = FALSE], 1, function(x) {
    levels(k3)[which.max(x)]
  }),
  stringsAsFactors = FALSE
)
# append cluster means as columns
top20_table <- cbind(top20_table, as.data.frame(cluster_means[top20, , drop = FALSE]))
top20_table <- top20_table %>% arrange(desc(range))

# Print the summary table
knitr::kable(top20_table)
```


```{r}
# 5) Order columns for heatmap: by k3, then by sample mean across top20
sample_means_top20 <- colMeans(expr_top100[top20, , drop = FALSE])
samp_df <- data.frame(id = colnames(expr_top100),
                      k3 = meta_pat$k3,
                      sample_mean = sample_means_top20,
                      stringsAsFactors = FALSE)
samp_df <- samp_df %>% arrange(k3, sample_mean)
sample_order <- samp_df$id

# 6) Prepare annotation for columns
annotation_col <- data.frame(k3 = factor(meta_pat$k3, levels = levels(k3)),
                             group = meta_pat$group)
rownames(annotation_col) <- meta_pat$id

# Optional: annotation colors (pick any palette you like)
annotation_colors <- list(
  k3 = setNames(c("#F8766D", "#00BA38", "#619CFF")[seq_along(levels(k3))], levels(k3)),
  group = c("NW" = "steelblue", "OW" = "orange", "OB" = "firebrick")
)

# 7) Plot pheatmap: scale rows to emphasize differences across proteins
pheatmap(expr_top100[top20, sample_order],
         scale = "row",
         cluster_rows = TRUE,
         cluster_cols = FALSE,        # columns are already ordered by k3 & sample mean
         show_rownames = TRUE,
         show_colnames = FALSE,
         annotation_col = annotation_col,
         annotation_colors = annotation_colors,
         color = colorRampPalette(c("blue", "white", "red"))(100),
         main = "Top 20 proteins (max-min across group 1 vs group 2)")
```


### Protein values per patient

We plot the protein distribution across patients in order to see if the expression pattern is similar or not.

```{r}
# Add probe IDs as a column
exprs_ALL_df <- data.frame(Protein = rownames(expr_ALL), expr_ALL)

# Melt the data frame into long format
expr_long <- reshape2::melt(exprs_ALL_df, id.vars = "Protein", variable.name = "patient", value.name = "Expression") 

# Add group variable
expr_long <- expr_long %>%
  dplyr::mutate(group = as.factor(substr(patient, 1,2)))


# Density plot
a <- ggplot(expr_long, aes(x = Expression, color = patient)) +
  geom_density() +
  theme_bw() +
  ggtitle("Expression density distributions per patient")

b <- ggplot(expr_long, aes(x = Expression, fill = 1)) +
  geom_density(alpha = 0.5) +
  theme_bw() +
  theme(legend.position = "none") +
  ggtitle("General expression density distributions")

# Density plot
c <- ggplot(expr_long, aes(x = Expression, color = group, fill = group)) +
  geom_density(alpha = 0.1) +
  theme_bw() +
  ggtitle("Expression density distributions per group")

# Density plot
d <- ggplot(expr_long, aes(x = Expression, color = group, fill = group)) +
  geom_boxplot(alpha = 0.1) +
  theme_bw() +
  ggtitle("Expression distributions' boxplots per group")


final_plot <- (a|b) / (c|d)


ggsave(
  filename = "results/expression_density_combined.png",
  plot = final_plot,
  width = 12,     # adjust as needed
  height = 10,    # adjust as needed
  dpi = 300
)
```

![](results/expression_density_combined.png)

### Mean vs SD per Protein

We also check the distribution of protein expression and the standard deviation of them acorss patients.

```{r}
# Compute mean and SD across patients for each protein
protein_stats <- exprs_ALL_df %>%
  tidyr::pivot_longer(-Protein, names_to = "patient", values_to = "Expression") %>%
  dplyr::group_by(Protein) %>%
  dplyr::summarise(
    mean_expr = mean(Expression, na.rm = TRUE),
    sd_expr   = sd(Expression, na.rm = TRUE)
  )
# Density plot of mean expression values
a <- ggplot(protein_stats, aes(x = mean_expr)) +
  geom_density(fill = "steelblue", alpha = 0.4) +
  theme_bw() +
  ggtitle("Density of Mean Expression Per Protein") +
  xlab("Mean Expression")

# Scatter plot: SD vs mean per protein
b <- ggplot(protein_stats, aes(x = mean_expr, y = sd_expr)) +
  geom_point(alpha = 0.6) +
  theme_bw() +
  ggtitle("SD vs Mean Expression per Protein") +
  xlab("Mean Expression") +
  ylab("Standard Deviation")

a | b
```

## Principal Component Analysis

This section performs a principal component analysis to explore global patterns in the protein expression data. First, the sample metadata is reordered so that it matches the order of samples in the expression matrix. This is essential to ensure that each sample is correctly annotated. The expression matrix is then transposed so that samples are treated as observations and proteins as variables, which is required for principal component analysis. The analysis reduces thousands of protein measurements into a small number of components that summarize the main sources of variation in the data.

If the variable is numeric, such as age, samples are colored along a continuous scale to show gradients across the data. If the variable is categorical, such as group or sex, samples are colored by category and confidence ellipses are added to visualize clustering tendencies. This approach helps evaluate whether samples with shared characteristics tend to group together in the global expression space. The resulting plots are arranged into a single figure for side by side comparison.

```{r, warning = FALSE, message=FALSE}
# Ensure metadata is ordered to match expression matrix
meta_pat <- meta_pat[match(colnames(expr_ALL), meta_pat$id), ]

# Transpose so samples are rows for PCA
pca_res <- prcomp(t(expr_ALL), scale. = TRUE)

# build PCA dataframe
pca_df <- data.frame(
  PC1 = pca_res$x[, 1],
  PC2 = pca_res$x[, 2],
  PC3 = pca_res$x[, 3],
  PC4 = pca_res$x[, 4],
  id = meta_pat$id,
  group = meta_pat$group,
  Sexo = meta_pat$Sexo,
  Otros = meta_pat$Otros,
  Edad = meta_pat$Edad
)

# Create PC pairs
pc_pairs <- list(
  c("PC1","PC2"),
  c("PC1","PC3"),
  c("PC1","PC4"),
  c("PC2","PC3"),
  c("PC2","PC4"),
  c("PC3","PC4")
)

# Meta variables 

color_vars <- c("Sexo", "Otros", "Edad", "group")


# Function to create pca_plot
make_pca_plot <- function(df, pcs, color_var) {
  ggplot(df, aes_string(x = pcs[1], y = pcs[2], color = color_var)) +
    geom_point(size = 3) +
    geom_text_repel(aes(label = id), size = 3) +
    theme_bw() +
    ggtitle(paste0(pcs[1], " vs ", pcs[2], " colored by ", color_var)) +
    xlab(paste0(pcs[1], " (", round(summary(pca_res)$importance[2, as.numeric(substr(pcs[1],3,3))] * 100, 1), "%)")) +
    ylab(paste0(pcs[2], " (", round(summary(pca_res)$importance[2, as.numeric(substr(pcs[2],3,3))] * 100, 1), "%)"))
}

# Generate plot list
plots <- list()

# Create each pca plot
for (pc in pc_pairs) {
  for (colvar in color_vars) {
    p <- make_pca_plot(pca_df, pc, colvar)
    plots <- append(plots, list(p))
  }
}

# Combinar todos los gráficos en una cuadrícula
final_plot <- wrap_plots(plots, ncol = 2)

# Save PCA plots
ggsave("results/PCA_all_combinations.png",
       final_plot,
       width = 16, height = 40, dpi = 300)

# print(final_plot)
```

![](results/PCA_all_combinations.png)


```{r, warning = FALSE, message=FALSE}
# Add groups to see if cluster together
library(factoextra)
library(ggpubr)
library(ggplot2)

# PCA with factoextra
res.pca <- prcomp(t(expr_ALL), scale.=TRUE, center=TRUE)

# Variables wanted to plot: 
vars <- c("group", "Sexo", "Otros", "Edad")
plots <- list()

for (v in vars) {
  vec <- meta_pat[[v]]
  # If numeric variable: 
  if (is.numeric(vec)) {
    
    p <- fviz_pca_ind(res.pca,
                      addEllipses = FALSE,
                      repel = TRUE, 
                      label = "none"
    ) +
      geom_point(aes(color = vec), size = 3) +
      scale_color_viridis_c(option = "plasma") +
      labs(color = v, title = paste("PCA grouped by", v))
    
  } else {
    # Categorical variable: 
    p <- fviz_pca_ind(res.pca,
                      addEllipses = TRUE,
                      ellipse.level = 0.95,
                      repel = TRUE,
                      palette = "Dark2",
                      habillage = vec, 
                      label = "none"
    )  +
      labs(title = paste("PCA grouped by", v))
  }
  
  # Save plot
  plots[[v]] <- p
}

# Combine 4 plots:
ggarrange(
  plots$group, plots$Sexo, plots$Otros, plots$Edad,
  # labels = vars,
  ncol = 2, nrow = 2
)

```



# Data models

## Individual protein levels

### BMI level model

Now, we are going to prepare the data for statistical modeling of individual protein expression levels. The metadata is again aligned with the expression matrix to guarantee correct sample matching. Body mass index and age are transformed in two ways. First, they are centered to make model interpretation more intuitive. Second, they are standardized so that all numeric predictors are on comparable scales, which improves model stability. The objective is to analyze how protein levels changes if the bmi changes. 

A preliminary linear model is fitted to evaluate collinearity among predictors. Variance inflation factors and diagnostic plots are used to check whether predictors provide redundant information. This step ensures that subsequent models are statistically sound and interpretable.

```{r, warning = FALSE, message=FALSE}
library(car)
# reorder metadata to match expr_ALL columns
meta_pat <- meta_pat[match(colnames(expr_ALL), meta_pat$id), ]

# basic check
stopifnot(all(colnames(expr_ALL) == meta_pat$id))

# Optionally center continuous covariates (helps interpret intercepts)
meta_pat$IMC_c  <- scale(meta_pat$IMC, center = TRUE, scale = FALSE)[,1]
meta_pat$Edad_c <- scale(meta_pat$Edad, center = TRUE, scale = FALSE)[,1]

# Scale numeric covariates to be on similar scales:
# Center and scale (z-score)
meta_pat$IMC_s  <- scale(meta_pat$IMC, center = TRUE, scale = TRUE)[,1]
meta_pat$Edad_s <- scale(meta_pat$Edad, center = TRUE, scale = TRUE)[,1]

# Consider looking for colinarity between predictors: 
model_vif <- lm(IMC ~ Edad + Sexo + group + Otros, data=meta_pat)
vif(model_vif)
plot(model_vif, which = 1, main = "Model Fit")
```

In this case, we drop group (it does not reach vif value = 5, but it's 'measuring' the same as the bmi).

After that, a multivariable linear model is fitted to test the association between protein expression and body mass index while adjusting for age, sex, and other covariates. A design matrix is constructed that encodes these predictors in a form suitable for high dimensional modeling. The limma framework is then applied to fit the model to all proteins simultaneously.

Empirical Bayes moderation is used to improve variance estimation, which is particularly important when sample sizes are limited. Results for the body mass index effect are extracted for all proteins and corrected for multiple testing. A volcano plot is generated to visualize both the magnitude and statistical significance of associations. Proteins with stronger and more significant associations are highlighted and labeled. The plot is saved for inclusion in the report.

```{r, warning = FALSE, message=FALSE}
# IMC: 

### Build design matrix
# Model: Expression ~ IMC + Edad + Sexo
# (Intercept corresponds to reference level of Sexo)
design_bmi <- model.matrix(~ IMC_s + Edad_s + Sexo + Otros, data = meta_pat) # Add DB and scaled data: 

colnames(design_bmi)
# Check design
print(head(design_bmi))

## Fit limma
# expr_ALL must be numeric matrix
expr_mat <- as.matrix(expr_ALL)
fit_bmi <- lmFit(expr_mat, design_bmi)
fit_bmi <- eBayes(fit_bmi, trend = TRUE, robust = TRUE) # Use empirical Bayes with robust options and trend 

### Extract results for BMI (IMC_c)
# Determine the exact coefficient name for IMC_c in design
coef_name <- "IMC_s"
if(!coef_name %in% colnames(design_bmi)) stop("Coefficient name for BMI not found in design.")

res_bmi <- topTable(fit_bmi, coef = coef_name, number = Inf, sort.by = "P") # res contains logFC (effect per unit of IMC_c), AveExpr, t, P.Value, adj.P.Val, B
head(res_bmi)

### 5. Add protein names column (rownames are proteins)
res_bmi <- res_bmi %>% 
  tibble::rownames_to_column(var = "Protein") %>%
  as.data.frame()

### 6. Volcano plot (ggplot2) - custom
# choose thresholds (you can change)
logFC_thr <- 0.2        # example: proteins with abs(logFC) > 0.2 considered biologically relevant (adjust as you wish)
padj_thr  <- 0.05

res_bmi$significant <- with(res_bmi, (adj.P.Val < padj_thr) & (abs(logFC) > logFC_thr))

volc_df_bmi <- res_bmi %>%
  mutate(minusLog10P = -log10(P.Value + 1e-300))  # avoid -Inf

p_volcano_bmi <- ggplot(volc_df_bmi, aes(x = logFC, y = minusLog10P)) +
  geom_point(aes(color = significant), alpha = 0.7) +
  scale_color_manual(values = c("grey50", "red")) +
  geom_vline(xintercept = c(-logFC_thr, logFC_thr), linetype = "dashed") +
  geom_hline(yintercept = -log10(padj_thr), linetype = "dashed") +
  theme_bw() +
  xlab("log2 fold change (per 1 BMI unit)") +
  ylab("-log10(p-value)") +
  ggtitle("Volcano plot: association of protein expression with BMI (IMC)") +
  theme(legend.position = "none")

# label top hits (by smallest adj.P.Val or largest effect)
top_to_label_bmi <- volc_df_bmi %>% arrange(adj.P.Val) %>% head(10)
p_volcano_bmi <- p_volcano_bmi +
  geom_text_repel(data = top_to_label_bmi,
                  aes(label = Protein),
                  size = 3,
                  max.overlaps = 20)

# Show plot (optional)
print(p_volcano_bmi)

# Save to file (PNG)
ggsave("results/volcano_IMC_limma.png", p_volcano_bmi, width = 8, height = 6, dpi = 300)
```

### Group comparisson

Finally, we wanted to evaluate differences in protein expression between predefined groups. First, a linear model is fitted that includes group as the main factor while adjusting for age, sex, and other covariates. An overall statistical test identifies proteins that vary across groups. Then, specific pairwise group comparisons are defined using contrasts.

For each contrast, the model is refitted and statistical results are extracted. A reusable function generates volcano plots for each comparison, highlighting proteins with both large expression differences and strong statistical support. The most significant proteins are labeled to facilitate biological interpretation. As output, you can also find several interactive tables with teh results of the different comparisons: 

```{r, warning = FALSE, message=FALSE}

# Anova (F-test): 
# Design with intercept (recommended)
design_group <- model.matrix(~ group + Edad_c + Sexo + Otros, data = meta_pat)
colnames(design_group) <- make.names(colnames(design_group))

# Verify
stopifnot(qr(design_group)$rank == ncol(design_group))

# Fit model
fit_group <- lmFit(expr_mat, design_group)
fit_group <- eBayes(fit_group, trend = TRUE, robust = TRUE)

res_overall <- topTable(fit_group, coef = grep("^group", colnames(design_group)),
                        number = Inf, sort.by = "F")


# Pairwise comparison: 
# Define contrasts for all pairwise comparisons
contr.matrix <- makeContrasts(
  OB_vs_NW = groupOB,
  OW_vs_NW = groupOW,
  OB_vs_OW = groupOB - groupOW,
  levels = design_group
)

# Fit model
fit2 <- contrasts.fit(fit_group, contr.matrix)
fit2 <- eBayes(fit2, trend = TRUE, robust = TRUE)

tt_over_norm <- topTable(fit2, coef="OW_vs_NW", number=Inf, adjust.method = "BH")
tt_obese_norm <- topTable(fit2, coef="OB_vs_NW", number=Inf, adjust.method = "BH")
tt_obese_over <- topTable(fit2, coef="OB_vs_OW", number=Inf,adjust.method = "BH")

# --- 5. Function to make volcano plots for a given contrast
make_volcano <- function(fit2, contrast_name, logFC_thr = 0.2, padj_thr = 0.05, top_n = 10) {
  res <- topTable(fit2, coef = contrast_name, number = Inf, sort.by = "P") %>%
    rownames_to_column("Protein") %>%
    as.data.frame()
  
  res$significant <- with(res, (adj.P.Val < padj_thr) & (abs(logFC) > logFC_thr))
  res$minusLog10P <- -log10(res$P.Value + 1e-300)
  
  # Volcano plot
  p <- ggplot(res, aes(x = logFC, y = minusLog10P)) +
    geom_point(aes(color = significant), alpha = 0.7) +
    scale_color_manual(values = c("grey50", "red")) +
    geom_vline(xintercept = c(-logFC_thr, logFC_thr), linetype = "dashed") +
    geom_hline(yintercept = -log10(padj_thr), linetype = "dashed") +
    theme_bw() +
    xlab("log2 fold change") +
    ylab("-log10(p-value)") +
    ggtitle(paste0("Volcano: ", contrast_name)) +
    theme(legend.position = "none")
  
  # Label top proteins
  top_to_label <- res %>% arrange(adj.P.Val) %>% head(top_n)
  p <- p + geom_text_repel(data = top_to_label,
                           aes(label = Protein),
                           size = 3,
                           max.overlaps = 20)
  return(p)
}

# --- 6. Make volcano plots for each contrast
p_OB_vs_NW <- make_volcano(fit2, "OB_vs_NW")
p_OW_vs_NW <- make_volcano(fit2, "OW_vs_NW")
p_OB_vs_OW <- make_volcano(fit2, "OB_vs_OW")

# --- 7. Optionally save plots
ggsave("results/volcano_OB_vs_NW.png", p_OB_vs_NW, width = 8, height = 6, dpi = 300)
ggsave("results/volcano_OW_vs_NW.png", p_OW_vs_NW, width = 8, height = 6, dpi = 300)
ggsave("results/volcano_OB_vs_OW.png", p_OB_vs_OW, width = 8, height = 6, dpi = 300)


```

Display the pairwise comparison in interactive tables: 
```{r, warning = FALSE, message=FALSE}
library(DT)
library(htmltools)

tt_over_norm$proteinID <- rownames(tt_over_norm)
tt_obese_norm$proteinID <- rownames(tt_obese_norm)
tt_obese_over$proteinID <- rownames(tt_obese_over)

# Named list of topTables
tt_list <- list(
  "OW_vs_NW" = tt_over_norm,
  "OB_vs_NW" = tt_obese_norm,
  "OB_vs_OW" = tt_obese_over
)

# Create a list of datatables
dt_list <- lapply(seq_along(tt_list), function(i) {
  tt <- tt_list[[i]]
  df_name <- names(tt_list)[i]
  
  datatable(
    head(tt, n = nrow(tt)),
    options = list(
      pageLength = 5,
      initComplete = JS(
        "function(settings, json) {",
        "$('div.dataTables_wrapper').find('table').css('font-size', '14px');",
        "$('div.dataTables_wrapper').find('caption').css({'font-size': '16px', 'font-weight': 'bold'});",
        "}"
      ),
      columnDefs = list(
        list(
          targets = "_all",
          render = JS(
            "function(data, type, row, meta) {",
            "if (typeof data === 'number') {",
            "  if (meta.col == 5) {",
            "    return parseFloat(data).toExponential(2);",
            "  } else {",
            "    return parseFloat(data).toFixed(3);",
            "  }",
            "} else {",
            "  return data;",
            "}",
            "}"
          )
        )
      )
    ),
    rownames = FALSE,
    caption = df_name
  )
})

# Render all tables at once
browsable(tagList(dt_list))
```

# Machine Learning models 
In that case, we are going to try a different approach (not a Differention expression analysis) to see if we can obtain some significant results. 

## Elastic net (glmnet)
### Goal

To identify proteins that genuinely distinguish between the three weight groups (normal weight (NW), overweight (OW), and obese (OB)) while properly accounting for potential confounders like age, sex, and having diabetes, and without mistaking random noise for true biological signal.

### Challenge
We’re working with a very small sample size (n = 24, 8 per group) but measuring hundreds or even thousands of proteins. In this “large p, small n” setting, any supervised learning method (whether Random Forest, Lasso, or elastic net) will almost always identify seemingly “important” proteins, even if the data contain no real association between proteins and group labels. This happens simply because, with so many variables, some will align with the outcome by pure chance. Standard importance scores or nominal p-values do not correct for this massive implicit multiple testing, leading to a high risk of false discoveries.

So we are going to perform a Permutation-Based Inference analysis.To address this, we use permutation testing (a non-parametric, assumption-free approach to establish a data-driven significance threshold). Null hypothesis (H₀): Protein expression profiles are unrelated to group membership; any observed association is due to random chance.

### Procedure:
* Randomly shuffle the group labels across samples — this destroys any true biological link between proteins and groups.
* Re-run the entire analysis pipeline on this permuted data: leave-one-out cross-validation, elastic net fitting, covariate adjustment, and computation of protein importance scores.
* Record the highest importance score observed across all proteins in that permutation (i.e., the best “fake” result).
* Repeat this process 100–1,000 times to build a null distribution of maximum importance scores — representing what we’d expect by chance alone.

Observation: In high-dimensional settings, the real question isn’t whether a protein is “important” in isolation — it’s whether it’s more important than the best spurious signal that arises when hunting through thousands of features. That’s why we focus on the maximum score per permutation.

### Defining Significance

We set our significance threshold at the 95th percentile of this null distribution. Only proteins whose observed importance score exceeds this threshold are considered statistically unlikely under the null hypothesis, effectively controlling the family-wise error rate (FWER) at α = 0.05.

This gives us a rigorous, conservative, and interpretable way to prioritize proteins for downstream validation, even in a severely underpowered cohort.

```{r, warning = FALSE, message=FALSE}
library(glmnet)
library(doParallel)
library(foreach)

# 1. PREPARE DATA 
set.seed(2025)

# Transpose to samples × proteins
X_proteins <- t(expr_mat)  # 24 × P
X_covars   <- model.matrix(~ Edad_c + Sexo + Otros, data = meta_pat)[, -1, drop = FALSE]  # 24 × K
y          <- meta_pat$group  # factor with 3 levels

# Combine: proteins + covariates
X_full <- cbind(X_proteins, X_covars)  # 24 × (P + K)

# Response as numeric (1,2,3) for multinomial
y_num <- as.numeric(y)

# Identify protein column indices (for importance extraction)
protein_names <- colnames(X_proteins)
protein_idx   <- 1:ncol(X_proteins)
covar_idx     <- (ncol(X_proteins) + 1):ncol(X_full)

# 2. LOO LOOP: FIT MODEL, RECORD COEFFICIENTS
n <- nrow(X_full)
alpha <- 0.9  # favor L1 (sparse selection); 1 = Lasso, 0 = Ridge

# Store coefficients for proteins only (ignore covariates)
coef_matrix <- matrix(0, nrow = length(protein_names), ncol = n)
colnames(coef_matrix) <- paste0("LOO_", 1:n)
rownames(coef_matrix) <- protein_names

# Optional: parallelize (n=24 is small, but okay)
cl <- makeCluster(min(detectCores(), 4))
registerDoParallel(cl)

results <- foreach(i = 1:n, .packages = c("glmnet")) %dopar% {
  # Leave out sample i
  X_train <- X_full[-i, , drop = FALSE]
  y_train <- y_num[-i]
  
  # Standardize predictors (glmnet does this internally, but we do it for clarity)
  # Note: glmnet standardizes by default; we let it handle it
  
  # Fit multinomial elastic net
  # Use lambda.min from CV? No—too unstable at n=23. Instead, use lambda.1se or fixed small lambda.
  # We'll use a *fixed small lambda* to ensure some regularization without CV.
  
  fit <- glmnet(
    x = X_train,
    y = factor(y_train),
    family = "multinomial",
    alpha = alpha,
    lambda = 0.01,  # small but non-zero; prevents overfitting
    standardize = TRUE,
    thresh = 1e-5,
    maxit = 1e5
  )
  
  # Extract coefficients for the final lambda (single value)
  # glmnet returns coef for each class; we take L1 norm across classes
  coefs <- coef(fit, s = 0.01)
  
  # coefs is a list of 3 (one per class); combine via max or L1 norm
  # We take the maximum absolute coefficient across classes
  coef_vec <- rep(0, nrow(X_train))
  for (cls in seq_along(coefs)) {
    c_vec <- as.vector(coefs[[cls]][-1])  # drop intercept
    coef_vec <- pmax(coef_vec, abs(c_vec))
  }
  
  # Return only protein coefficients
  coef_vec[protein_idx]
}

# stopCluster(cl)

# 3. AGGREGATE LOO COEFFICIENTS 
# Rebuild matrix
for (i in 1:n) {
  coef_matrix[, i] <- results[[i]]
}

# Feature stability: proportion of LOO folds where |coef| > 0
nonzero_freq <- rowMeans(coef_matrix != 0)

# Mean absolute coefficient (magnitude)
mean_coef <- rowMeans(coef_matrix)

# Combined score: stability × magnitude
importance_score <- nonzero_freq * mean_coef

# Rank proteins
ranked_proteins <- sort(importance_score, decreasing = TRUE)

# 4. PERMUTATION BASELINE
# To assess how often noise gives high scores

n_perm <- 100
null_scores <- foreach(p = 1:n_perm, 
                       .packages = c("glmnet"),
                       .export = c("X_full", "y_num", "n", "protein_idx", "alpha")) %dopar% {
                         set.seed(1000 + p)
                         y_perm <- sample(y_num)
                         
                         coef_mat_null <- matrix(0, nrow = length(protein_names), ncol = n)
                         
                         for (i in 1:n) {
                           X_train <- X_full[-i, , drop = FALSE]
                           y_train <- y_perm[-i]
                           
                           # Optional: skip if degenerate (not strictly needed but safe)
                           if (length(unique(y_train)) < 2) {
                             next
                           }
                           
                           fit <- glmnet(
                             x = X_train,
                             y = factor(y_train),
                             family = "multinomial",
                             alpha = alpha,
                             lambda = 0.01,
                             standardize = TRUE,
                             thresh = 1e-5
                           )
                           
                           coefs <- coef(fit, s = 0.01)
                           coef_vec <- rep(0, ncol(X_train))
                           
                           for (cls in seq_along(coefs)) {
                             # ✅ CORRECT: drop intercept (first element) with -1
                             c_vec <- as.vector(coefs[[cls]][-1])  # ←←← THIS IS THE FIX
                             coef_vec <- pmax(coef_vec, abs(c_vec))
                           }
                           
                           coef_mat_null[, i] <- coef_vec[protein_idx]
                         }
                         
                         # Compute importance score per protein
                         stability_null <- rowMeans(coef_mat_null != 0, na.rm = TRUE)
                         magnitude_null <- rowMeans(coef_mat_null, na.rm = TRUE)
                         score_null <- stability_null * magnitude_null
                         
                         # Return max null score (for thresholding)
                         max(score_null, na.rm = TRUE)
                       }
null_thresh <- quantile(unlist(null_scores), 0.95)

# Significant proteins
sig_proteins <- names(which(importance_score > null_thresh))

cat("Proteins exceeding 95% null threshold:", length(sig_proteins), "\n")
head(ranked_proteins, 10)

library(ggplot2)
# Real scores: one per protein
df_real <- data.frame(
  Score = importance_score,
  Type = "Real"
)

# Null scores: one per permutation (each is a MAX null score)
df_null <- data.frame(
  Score = unlist(null_scores),  # ensure it's a vector
  Type = "Null (max per perm)"
)

# Combine for ggplot
df_plot <- rbind(df_real, df_null)

# Plot
library(ggplot2)
ggplot(df_plot, aes(x = Score, fill = Type)) +
  geom_density(alpha = 0.6) +  # density is smoother than histogram for this
  geom_vline(xintercept = null_thresh, linetype = "dashed", color = "red", size = 1) +
  labs(
    title = "Real protein importance scores vs. null distribution",
    subtitle = paste("Null threshold (95%):", round(null_thresh, 3)),
    x = "Importance score (stability × magnitude)",
    y = "Density"
  ) +
  scale_fill_manual(values = c("Real" = "steelblue", "Null (max per perm)" = "firebrick")) +
  theme_minimal()


top_proteins <- head(sort(importance_score, decreasing = TRUE), 5)
df_top <- data.frame(
  Score = top_proteins,
  Label = names(top_proteins)
)

ggplot(df_plot, aes(x = Score, fill = Type)) +
  geom_density(alpha = 0.6) +
  geom_vline(xintercept = null_thresh, linetype = "dashed", color = "red", size = 1) +
  geom_point(data = df_top, aes(x = Score, y = 0), 
             color = "black", size = 3, inherit.aes = FALSE) +
  geom_text(data = df_top, aes(x = Score, y = 0.1, label = Label), 
            hjust = 0.5, vjust = -1, inherit.aes = FALSE) +
  labs(
    title = "Real vs. Null Importance Scores",
    subtitle = paste("Threshold (95% null):", round(null_thresh, 3)),
    x = "Importance score",
    y = "Density"
  ) +
  scale_fill_manual(values = c("Real" = "steelblue", "Null (max per perm)" = "firebrick")) +
  theme_minimal()

stopCluster(cl)

```

# Conclusions

In summary, we reached the following conclusions.

## Observational study

* We identified two individuals, 0B8 and 0W8, with unusual expression patterns that form isolated clusters, as shown in the heatmap. It would be important to review the quality control metrics and metadata for these individuals to determine whether there is a technical or biological explanation.
* The data did not cluster according to the predefined groups. Instead of three clearly separated groups (normal weight, overweight, and obese), we observed three mixed clusters: one consisting of two outlier samples, one cluster containing mostly normal weight individuals with some overweight and obese samples, and another cluster composed mainly of overweight and obese individuals with one normal weight sample.
* No clear differences associated with age or sex were observed.

## Differential expression study

* We did not identify any statistically significant results after correcting for multiple testing, either in pairwise group comparisons (for example, normal weight versus obese or obese versus overweight) or when modeling body mass index as a continuous variable across all samples.
* Enrichment analysis was not performed because no sets of differentially expressed proteins were identified.
* We also evaluated a machine learning approach using an elastic net classifier to assess whether it could outperform standard differential expression analysis. Permutation tests were included to ensure that any classification performance exceeded what would be expected by chance. No statistically significant results were observed using this approach.

## Take home message

* We observe trends in protein expression that suggest potential group specific signatures; however, these differences do not remain statistically significant after correction for multiple testing. This is likely due to the small sample size, with only eight individuals included in the study. Increasing the sample size would likely improve statistical power.
* Two mixed clusters were identified. It would be valuable to investigate protein expression differences between these clusters and to assess whether they reflect biological patterns not directly related to body mass index, such as differences in body fat composition. Having access to body fat percentage measurements would be particularly informative.




